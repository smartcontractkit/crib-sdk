// Code generated by gowrap. DO NOT EDIT.
// template: https://raw.githubusercontent.com/hexdigest/gowrap/c6122ceca792c03665872a86a39ef60d026e4a58/templates/retry
// gowrap: http://github.com/hexdigest/gowrap

package helm

import (
	"context"
	"time"

	"github.com/smartcontractkit/crib-sdk/internal/core/domain"
	_sourcePort "github.com/smartcontractkit/crib-sdk/internal/core/port"
)

// HelmClientWithRetry implements _sourcePort.HelmClient interface instrumented with retries
type HelmClientWithRetry struct {
	_sourcePort.HelmClient
	_retryCount    int
	_retryInterval time.Duration
}

// NewHelmClientWithRetry returns HelmClientWithRetry
func NewHelmClientWithRetry(base _sourcePort.HelmClient, retryCount int, retryInterval time.Duration) HelmClientWithRetry {
	return HelmClientWithRetry{
		HelmClient:     base,
		_retryCount:    retryCount,
		_retryInterval: retryInterval,
	}
}

// AddRepo implements _sourcePort.HelmClient
func (_d HelmClientWithRetry) AddRepo(ctx context.Context, release _sourcePort.ChartReleaser) (err error) {
	err = _d.HelmClient.AddRepo(ctx, release)
	if err == nil || _d._retryCount < 1 {
		return
	}
	_ticker := time.NewTicker(_d._retryInterval)
	defer _ticker.Stop()
	for _i := 0; _i < _d._retryCount && err != nil; _i++ {
		select {
		case <-ctx.Done():
			return
		case <-_ticker.C:
		}
		err = _d.HelmClient.AddRepo(ctx, release)
	}
	return
}

// CurrentVersion implements _sourcePort.HelmClient
func (_d HelmClientWithRetry) CurrentVersion(ctx context.Context, release _sourcePort.ChartReleaser) (h1 domain.HelmChartVersion, err error) {
	h1, err = _d.HelmClient.CurrentVersion(ctx, release)
	if err == nil || _d._retryCount < 1 {
		return
	}
	_ticker := time.NewTicker(_d._retryInterval)
	defer _ticker.Stop()
	for _i := 0; _i < _d._retryCount && err != nil; _i++ {
		select {
		case <-ctx.Done():
			return
		case <-_ticker.C:
		}
		h1, err = _d.HelmClient.CurrentVersion(ctx, release)
	}
	return
}

// LatestVersion implements _sourcePort.HelmClient
func (_d HelmClientWithRetry) LatestVersion(ctx context.Context, release _sourcePort.ChartReleaser) (h1 domain.HelmChartVersion, err error) {
	h1, err = _d.HelmClient.LatestVersion(ctx, release)
	if err == nil || _d._retryCount < 1 {
		return
	}
	_ticker := time.NewTicker(_d._retryInterval)
	defer _ticker.Stop()
	for _i := 0; _i < _d._retryCount && err != nil; _i++ {
		select {
		case <-ctx.Done():
			return
		case <-_ticker.C:
		}
		h1, err = _d.HelmClient.LatestVersion(ctx, release)
	}
	return
}

// ListVersions implements _sourcePort.HelmClient
func (_d HelmClientWithRetry) ListVersions(ctx context.Context, release _sourcePort.ChartReleaser) (h1 domain.HelmChartVersions, err error) {
	h1, err = _d.HelmClient.ListVersions(ctx, release)
	if err == nil || _d._retryCount < 1 {
		return
	}
	_ticker := time.NewTicker(_d._retryInterval)
	defer _ticker.Stop()
	for _i := 0; _i < _d._retryCount && err != nil; _i++ {
		select {
		case <-ctx.Done():
			return
		case <-_ticker.C:
		}
		h1, err = _d.HelmClient.ListVersions(ctx, release)
	}
	return
}

// PullRepo implements _sourcePort.HelmClient
func (_d HelmClientWithRetry) PullRepo(ctx context.Context, release _sourcePort.ChartReleaser) (f1 _sourcePort.FileReader, err error) {
	f1, err = _d.HelmClient.PullRepo(ctx, release)
	if err == nil || _d._retryCount < 1 {
		return
	}
	_ticker := time.NewTicker(_d._retryInterval)
	defer _ticker.Stop()
	for _i := 0; _i < _d._retryCount && err != nil; _i++ {
		select {
		case <-ctx.Done():
			return
		case <-_ticker.C:
		}
		f1, err = _d.HelmClient.PullRepo(ctx, release)
	}
	return
}

// TemplateRepo implements _sourcePort.HelmClient
func (_d HelmClientWithRetry) TemplateRepo(ctx context.Context, release _sourcePort.ChartReleaser, reader _sourcePort.FileReader) (ba1 []byte, err error) {
	ba1, err = _d.HelmClient.TemplateRepo(ctx, release, reader)
	if err == nil || _d._retryCount < 1 {
		return
	}
	_ticker := time.NewTicker(_d._retryInterval)
	defer _ticker.Stop()
	for _i := 0; _i < _d._retryCount && err != nil; _i++ {
		select {
		case <-ctx.Done():
			return
		case <-_ticker.C:
		}
		ba1, err = _d.HelmClient.TemplateRepo(ctx, release, reader)
	}
	return
}

// UpdateRepo implements _sourcePort.HelmClient
func (_d HelmClientWithRetry) UpdateRepo(ctx context.Context, release _sourcePort.ChartReleaser) (err error) {
	err = _d.HelmClient.UpdateRepo(ctx, release)
	if err == nil || _d._retryCount < 1 {
		return
	}
	_ticker := time.NewTicker(_d._retryInterval)
	defer _ticker.Stop()
	for _i := 0; _i < _d._retryCount && err != nil; _i++ {
		select {
		case <-ctx.Done():
			return
		case <-_ticker.C:
		}
		err = _d.HelmClient.UpdateRepo(ctx, release)
	}
	return
}

// VendorRepo implements _sourcePort.HelmClient
func (_d HelmClientWithRetry) VendorRepo(ctx context.Context, release _sourcePort.ChartReleaser) (f1 _sourcePort.FileReader, err error) {
	f1, err = _d.HelmClient.VendorRepo(ctx, release)
	if err == nil || _d._retryCount < 1 {
		return
	}
	_ticker := time.NewTicker(_d._retryInterval)
	defer _ticker.Stop()
	for _i := 0; _i < _d._retryCount && err != nil; _i++ {
		select {
		case <-ctx.Done():
			return
		case <-_ticker.C:
		}
		f1, err = _d.HelmClient.VendorRepo(ctx, release)
	}
	return
}
